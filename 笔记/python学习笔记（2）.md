2017.9.8

### python学习笔记（2）

__有关元类的介绍__:`https://segmentfault.com/a/1190000007460181` && `http://blog.jobbole.com/21351/`

## python中变量的命名规范

1. 所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的.
2. 用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含).
3. 用双下划线(__)开头的实例变量或方法表示类内私有.
4. 将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.
5. 对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.
6. python中所有的`__xxx__`方法都有一定的含义，代表一定的协议，相当于CSharp和Java中的接口。

__特殊说明：__

`__new__` 是在 `__init__` 之前被调用的特殊方法，它用来创建对象**并返回**创建后的对象，对它的参数解释如下：

- cls：当前准备创建的类
- name：类的名字
- bases：类的父类集合
- attrs：类的属性和方法，是一个字典



### 一. 高阶函数

函数本身也可以赋值给变量，即：变量可以指向函数。

例：f  = abs  此时变量f 指向了求绝对值函数 abs。

传入函数：

既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

```python
def add(x, y, f):
    return f(x) + f(y)
    
#调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs
>>> add(-5, 6, abs)
11
```



### 2.map()/reduce()

### map()

格式： 
map(func, seq1[, seq2,…]) 
第一个参数接受一个函数名，后面的参数接受一个或多个可迭代的序列，返回的是一个集合。

注：Python函数编程中的map()函数是将func作用于seq中的每一个元素，并将所有的调用的结果作为一个list返回。

### reduce()

reduce函数即为化简，它是这样一个过程：每次迭代，将上一次的迭代结果（第一次时为init的元素，如没有init则为seq的第一个元素）与下一个元素一同执行一个二元的func函数。在reduce函数中，init是可选的，如果使用，则作为第一次迭代的第一个元素使用。

简单来说，可以用这样一个形象化的式子来说明：
`reduce( func, [1, 2,3] ) = func( func(1, 2), 3)`

**3.filter()**

和`map()`类似，`filter()`也接收一个函数和一个序列。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据**返回值是`True`还是`False`决定保留还是丢弃该元素。**

把一个序列中的空字符串删掉，可以这么写：

```python
def not_empty(s):
    return s and s.strip()

list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))
# 结果: ['A', 'B', 'C']
```



**4.sorted()**

Python内置的`sorted()`函数就可以对list进行排序。此外，`sorted()`函数也是一个高阶函数，它还可以接收一个`key`函数来实现自定义的排序，例如按绝对值大小排序：

```python
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
```

key指定的函数将作用于list的每一个元素上，并**根据key函数返回的结果**进行排序。



### 二.Python中字符串查找方法

**1 find()** 方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1。eg:

```python
info = 'abca'

print info.find('a')##从下标0开始，查找在字符串里第一个出现的子串，返回结果：0

```

**2 index()** 方法：

python 的index方法是在字符串里查找子串第一次出现的位置，类似字符串的find方法，不过比find方法更好的是，如果查找不到子串，会抛出异常，而不是返回-1。

rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。

### 三.匿名函数

在代码中，有时某个函数只在一个地方起作用，此时就不需要显式地定义函数，直接传入匿名函数更方便。

匿名函数`lambda x: x * x`实际上等价于：

```python
def f(x):
    return x * x
```

关键字`lambda`表示匿名函数，冒号前面的`x`表示函数参数。匿名函数有个限制，就是只能有一个表达式，不用写`return`，返回值就是该表达式的结果。

### 四.偏函数（from functools import partial）

偏函数将所要承载的函数作为`partial()`函数的第一个参数，原函数的各个参数依次作为`partial()`函数后续的参数，除非使用关键字参数。通过functools模块被用户调用。

简单总结`functools.partial`的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。

```python
from functools import partial
#利用偏函数定义二进制转换函数
bin2dec = partial( int, base=2 )
print bin2dec( '0b10001' )  # 17
print bin2dec( '10001' )  # 17
#利用偏函数定义16进制转换函数
hex2dec = partial( int, base=16 )
print hex2dec( '0x67' )  # 103
print hex2dec( '67' )  # 103

```



### 五. 返回函数和闭包（难点）

因为函数本身也是对象，高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。

一个函数和它的环境变量合在一起，就构成了一个闭包(closure)。在Python中，所谓的闭包是一个包含有环境变量取值的函数对象。环境变量取值被保存在函数对象的__closure__属性中。

另一个需要注意的问题是:**返回的函数并没有立刻执行，而是直到调用了f ()才执行。**我们来看一个例子：

```python
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()

>>> f1()
9
>>> f2()
9
>>> f3()
9
```

全部都是`9`！原因就在于返回的函数（内层函数）引用了变量`i`，但它并非立刻执行。在调用外层函数count()时，内层函数并没有执行。

f1,f2,f3 = count() ---------> [f1,f2,f3]。 count()中每次循环产生一个函数，count()返回的是一个list[f(),f(),f()]，f()返回的值是i*i。在完成外部函数的调用后，i已经变成3了。所以f()的值是9，结果是[9,9,9]。

返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。



